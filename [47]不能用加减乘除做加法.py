# -*- coding: utf-8 -*-
'''
写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。
'''

def add(x1,x2):
    s = x1 ^ x2
    c = x1 & x2
    if c == 0:
        return s
    deal = dealInf(s,c<<1)
    return add(s,c<<1) if deal == -1 else deal

def dealInf(s, c):
    if s >= 0 or c==0 or c&(c-1) != 0:
        # 和不是负数或进位不止一个1
        return -1
    mask,temp = -1,s
    while c != 1:
        temp >>= 1
        c >>= 1
        mask <<= 1
    # 判断是否最高位
    return mask^s if temp == -1 else -1

'''
思路：封印加减乘除，能用的操作只剩下求余和位运算。从二进制入手，对于二进制的x1和x2，不考虑进位的和为s=x1^x2，进位标志为c=x1&x2，若c不全为0，则递归求解add(c<<1,s)。
由于python无长度限度，如果在负数最高位进1的话，迭代就停不下来了，须手动将高位设为0。此处采用的方法是构造一个数mask，使得高位为1，低位为0，则s与该数的异或结果即为高位为0，低位不变。mask可以由-1左移产生。
边界：全是0，有一个是0，都是正数，一正一负和为正，一正一负和为负，都是负数，相加为0，相加为-1
'''
print('输入：%s %s，输出：%s，答案：%s' % (0,0, add(0,0), 0))
print('输入：%s %s，输出：%s，答案：%s' % (0,2, add(0,2), 2))
print('输入：%s %s，输出：%s，答案：%s' % (0,-2, add(0,-2), -2))
print('输入：%s %s，输出：%s，答案：%s' % (-1,-2, add(-1,-2), -3))
print('输入：%s %s，输出：%s，答案：%s' % (1,-2, add(1,-2), -1))
print('输入：%s %s，输出：%s，答案：%s' % (1,2, add(1,2), 3))
print('输入：%s %s，输出：%s，答案：%s' % (-3,3, add(-3,3), 0))
print('输入：%s %s，输出：%s，答案：%s' % (-3,2, add(-3,2), -1))
print('输入：%s %s，输出：%s，答案：%s' % (-2,3, add(-2,3), 1))
